Array.addSlots(

  # Access the value at the given 0-based index
  # Callable with the syntax: array[index]
  "[]": { |index|
    BuiltIn.arrayGet(array: self, index: index)
  },

  # Set a value in this array at the given index
  # Callable with the syntax: array[index] = to
  "[]=": { |index, to|
    BuiltIn.arraySet(array: self, index: index, to: to)
  },

  # Iterate over each entry in the array, evaluating the passed-in block
  # for every element.
  each: { |block|
    BuiltIn.arrayEach(array: self, block: block)
  },

  # Append a value to the end of the array
  push: { |object|
    BuiltIn.arrayPush(array: self, object: object)
  },

  # Remove and return the last entry in the array.
  # Returns Null if the array is empty.
  pop: {
    BuiltIn.arrayPop(array: self)
  },

  # Return the number of elements in this array
  length: {
    BuiltIn.arrayLength(array: self)
  },

  # Is this array empty?
  isEmpty: {
    length() == 0
  },

  "==": { |other|
    # TODO: Update when we support `super` calls.
    objectId() == other.objectId() || {
      other.is(Array) &&
      { length() == other.length() } &&
      { allElementsEqual(other) }
    }
  },

  allElementsEqual: { |other|
    i = 0
    equal = true

    each({ |element|
      # If we've already found a mis-match, fly past the rest
      # TODO: Revisit when we've got a way to short-circuit the rest
      # of the invocations, like `next`
      equal.do(
        ifTrue: { equal = (element == other[i]) },
      )

      i = i + 1
    })

    equal
  },

  toString: {
    buf = "["
    i = 0

    each({ |element|
      buf = buf + element.toString()
      i = i + 1

      (i < length()).do(
        ifTrue: { buf = buf + ", " }
      )
    })

    buf + "]"
  },
)
